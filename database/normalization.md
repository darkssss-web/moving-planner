# Проектирование базы данных для Moving Planner

В этом документе описан процесс проектирования и нормализации
базы данных для приложения планирования переезда **Moving Planner**.

Приложение помогает пользователю:
- планировать комнаты в новой квартире,
- создавать коробки и раскладывать по ним вещи,
- ставить задачи по переезду и отслеживать их выполнение.

---

## Предметная область и сущности

Основные сущности:

- **User** — пользователь приложения.
- **Room** — комната назначения (кухня, спальня и т.п.).
- **Box** — коробка, в которую складываются вещи.
- **Item** — отдельная вещь.
- **Status** — статус задачи (справочник).
- **Task** — задача, связанная с переездом.

---

## Денормализованная исходная таблица

Представим, что изначально вся информация хранилась в одной таблице:

`MoveLog(
    log_id,
    user_id, username, user_email,
    room_id, room_name,
    box_id, box_label, box_notes,
    item_id, item_name, item_description, is_fragile, value_estimate,
    task_id, task_title, task_description, task_due_date,
    status_name
)`

### Проблемы такой структуры

1. **Избыточность данных**
   - `username` и `user_email` повторяются для каждой записи пользователя.
   - `room_name` повторяется для каждой вещи/коробки в комнате.
   - `box_label` и `box_notes` повторяются для каждой вещи в коробке.
   - `status_name` повторяется для всех задач с одинаковым статусом.

2. **Аномалии обновления**
   - Если изменился `email` пользователя, нужно менять его во всех строках.
   - Если переименовали комнату, нужно обновлять все строки с этой комнатой.
   - Если изменили текст статуса, нужно обновлять множество записей.

3. **Аномалии удаления**
   - При удалении последней вещи в коробке можно случайно потерять данные о самой коробке.
   - При удалении последней задачи можно потерять статус, если он нигде больше не используется.

4. **Аномалии вставки**
   - Нельзя описать новую комнату или создать коробку без хотя бы одной вещи.
   - Нельзя создать новый статус, если нет ни одной задачи с этим статусом.

Такая структура не подходит для масштабируемой системы.

---

## Нормализация до 1NF

**Цель:** все атрибуты должны быть атомарными, без повторяющихся групп и списков значений.

**Решения:**

- Выносим основные сущности в отдельные таблицы:
  - `Users` — данные пользователей.
  - `Rooms` — комнаты.
  - `Boxes` — коробки.
  - `Items` — вещи.
  - `Statuses` — возможные статусы задач.
  - `Tasks` — задачи по переезду.

- Каждая строка в таблице описывает один объект:
  - одна вещь,
  - одна коробка,
  - одна комната,
  - одна задача.

**Результат:** все атрибуты атомарны, нет множественных значений в одном поле.

---

## Нормализация до 2NF

2NF имеет смысл для таблиц с **составным первичным ключом**:
неключевые атрибуты не должны зависеть только от части этого ключа.

В итоговой схеме каждая таблица имеет **простой** первичный ключ:

- `Users(user_id)`
- `Rooms(room_id)`
- `Boxes(box_id)`
- `Items(item_id)`
- `Statuses(status_id)`
- `Tasks(task_id)`

Составных PK нет → частичных зависимостей нет.

**Результат:** каждая таблица находится как минимум во 2NF.

---

## Нормализация до 3NF

3NF требует отсутствия **транзитивных зависимостей**:
неключевые атрибуты должны зависеть только от первичного ключа,
а не друг от друга.

Применяем к нашей схеме:

- Статус задачи (`status_name`) вынесен в отдельную таблицу `Statuses`.
  В таблице `Tasks` хранится только `status_id`.
- Данные пользователя (`username`, `email`) зависят только от `user_id`
  и вынесены в таблицу `Users`.
- Названия комнат (`name`) зависят только от `room_id` и находятся в таблице `Rooms`.
- Описание коробки (`label`, `notes`) зависит только от `box_id`
  и хранится в таблице `Boxes`.
- Атрибуты вещи (`name`, `description`, `is_fragile`, `value_estimate`)
  зависят только от `item_id` и находятся в таблице `Items`.

Таким образом, все неключевые атрибуты зависят только от PK своей таблицы.

**Результат:** схема приведена к 3NF, транзитивные зависимости устранены.

---

## Итоговая нормализованная схема (3NF)

- **Users**  
  (`user_id` PK, `username`, `email`, `created_at`)

- **Rooms**  
  (`room_id` PK, `user_id` FK → Users,  
  `name`, `description`, `created_at`)

- **Boxes**  
  (`box_id` PK, `user_id` FK → Users, `room_id` FK → Rooms,  
  `label`, `notes`, `created_at`)

- **Items**  
  (`item_id` PK, `user_id` FK → Users, `room_id` FK → Rooms, `box_id` FK → Boxes,  
  `name`, `description`, `is_fragile`, `value_estimate`)

- **Statuses**  
  (`status_id` PK, `name`)

- **Tasks**  
  (`task_id` PK, `user_id` FK → Users, `status_id` FK → Statuses,  
  `title`, `description`, `due_date`, `created_at`)

---

## DDL-скрипт и тестовые данные

- Файл **`database/schema.sql`** содержит полный DDL-скрипт
  для создания нормализованной схемы в SQLite
  (внешние ключи и индексы включены).
- Файл **`database/seed_data.sql`** содержит тестовые данные
  для проверки корректности структуры и запросов.

---

## Вывод

База данных приложения **Moving Planner**:

- описывает предметную область переезда (комнаты, коробки, вещи, задачи),
- приведена к **третьей нормальной форме (3NF)**,
- защищена от основных аномалий вставки, обновления и удаления,
- готова к использованию в приложении и последующей доработке.
